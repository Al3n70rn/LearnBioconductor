<!--
%\VignetteIndexEntry{02.2 Other Sequence Analysis Work Flows}
%\VignettePackage{LearnBioconductor}
%\VignetteEngine{knitr::knitr}
-->

```{r setup, echo=FALSE}
library(LearnBioconductor)
stopifnot(BiocInstaller::biocVersion() == "3.0")
```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# Common Sequence Analysis Work Flows

Martin Morgan, Sonali Arora<br/>
October 28, 2014

## ChIP-seq

(Martin)

Work flow

R / Bioconductor resources

## Variants

Work flow

R / Bioconductor resources

## Copy Number Analysis Workflow

Copy Number Variation (CNV's) refers to the duplication or deletion of DNA 
segments larger than 1 kbp. CNV's are structure variations in the genome 
which range in length between 50 bp and 1 Mbp. They are widespread among 
humans - on an average 12 CNVs exist per individual in comparison to the 
reference genome. They have also been shown to play a role in diseases such 
as autism, breast cancer, obesity, Alzheimerâ€™s disease and schizophrenia 
among other diseases. 

### Experimental design

Like any other genomic analysis, before we start a copy Number 
analysis, we need to set up our experimental design. Here, we highlight two 
specific pointers that one needs to keep in mind while designing a copy number
analysis. 

* __Tumor and normal samples__

Are we planning to just find copy number profile in individuals? For 
example, how does the copy number profile for a region evolve over a certain 
period of time?( Here we are comparing the copy number profile to a reference 
genome)

Are we planning to compare copy number profiles from tumor vs normal profiles?
For example, we may be trying to find out of copy number changes are responsible
for a certain form of cancer and want to find the exact genomic region against
which a treatment can be developed. 

There are different packages and different functions inside the same package
which handle CNV for tumor and normal samples or CNV in samples.  

* __Germ line versus somatic CNV__

Germ line CNV are relatively short (few bp to few Mbp) copy number changes that 
the individual inherit from one of the two gametes (sperm or egg) and thus are 
typically present in 100% of cells.

Somatic CNV (often called CNA where A stands for alterations or aberration) are
copy number changes of any size and amount (from a few bases to whole 
chromosomes) that happen (and often carry on happening) in cancer cells. 
Cancer cells can be aneuploid (that means they are largely triploid, 
tetraploid or even aploid) and can have high focal amplifications 
(some regions could have many copies: it is not unusual to have 8-12 copies for 
some regions). Furthermore, because tumor samples are typically an admixture 
of normal and cancer cells, the tumor purity in unknown and variable. 

Different algorithms assume different assumptions while handling Somatic CNV 
or germ line CNV. Typically, germ line cnv caller can assume:
- The genome is largely diploid
- The sample is pure and homogeneous
-  Any gain or loss should be 50% move coverage or 50% less
because of those reason, they can focus more on associating p-values for each 
call and it is possible to estimate False Positives/False Negatives

Somatic CNA callers cannot take any of the assumption above, or if they do, 
they have limited scope.

* __Sequencing Techonology__ 

    + **What kind of Sequencing Data are we working with?** 
    
    Is it array CGH data, SNP array or Next generation sequencing data? For 
    example, the `r Biocpkg("CGHbase")` detects CNV's in arrayCGH data  whereas 
    the `r Biocpkg("seqCNA")` among others detects CNV's in high-throughput 
    sequencing data. 

    + **Amount of Genome being Sequenced - Whole Genome vs Exome Genome?**
    
    Are we looking for copy number across the whole genome or are we looking for 
    copy number only in exomes? Again different packages handle different kind 
    of sequencing data. For example, The Bioconductor package 
    `r Biocpkg("exomeCopy")` detects CNV in exome sequencing data whereas the 
    Bioconductor package `r Biocpkg("cn.mops")` detects CNV in whole genome 
    sequencing data.

    + **Which platform was the sequencing done on ?**
    
    A lot of packages are specific to detecting CNV in platform specific data. 
    For example, the `r Biocpkg("crlmm")` detects CNV's in Affymetrix SNP 5.0 
    and 6.0 and Illumina arrays whereas the `r Biocpkg("CopyNumber450K")` 
    detects them in Illumina 450k methylation microarrays. 

    + **What is the coverage of sequenced data?**  
    
    Most packages work well with high sequencing data, but some packages are 
    designed to work well with low coverage data. It is best to recognize how  
    coverage of our data will affect the choice of the package we use for our 
    analysis at an early stage. 

* __Copy Number Analysis Algorithm ?__
    
Since statistics plays a huge role in copy number analysis, we should also 
spend some time in thoroughly understanding the underlying algorithm of the 
R package being used. A few questions to consider while choosing a package 
would be - 

a) How is our chosen package binning and counting reads?
b) Any pre-processing required from our end? Is it trimming the reads 
internally? 
c) What segmentation algorithm is being used ? For example Does the package 
use Circular Binary Segmentation, HMM based methods etc. 
d) How efficiently can it handle big data ? Do I need additional 
computational resources to run the analysis ? Does the function run in 
parallel ?

### Available Resources in Bioconductor 

Bioconductor currently has about **41 packages for Copy Number Analysis**. 
To find these, one can visit the 
[biocViews page](http://www.bioconductor.org/packages/devel/BiocViews.html#___Software.) 
link and type "CopyNumberVariation" in the "Autocomplete biocViews search"

### Workflow using cn.mops 

Lets work through a small example to illustrate how quick a copy number analysis
can be once you've figured out all the logistics. We will also find the genes 
that lie within the detected copy number regions. 

For this analysis, I chose the `r Biocpkg("cn.mops")` as it helps us with 
- detecting germline CNVs
- works well with low coverage data 
- handles both single copy number analysis and tumor vs normal copy number 
analysis
- uses parallel processing internally so we get fast computation
- handles whole genome sequencing data
- supports GenomicRanges infrastructure which allows easy workflows with other
Bioconductor packages.
```{r message=FALSE}
library(cn.mops)

tumorBam <- "tumorA.chr4.bam"
normalBam <- "normalA.chr4.bam"

## dowload the tumor normal pair Bam files for chr4. 
if(!all(file.exists(c(tumorBam, normalBam)))){
   amazonDir <- "http://s3.amazonaws.com/copy-number-analysis/"
    download.file(url = paste0(amazonDir, tumorBam), destfile = tumorBam)
    download.file(url = paste0(amazonDir, tumorBam, ".bai"), 
        destfile = paste0(tumorBam, ".bai"))
    download.file(url = paste0(amazonDir, normalBam), destfile = normalBam)
    download.file(url = paste0(amazonDir, normalBam, ".bai"), 
        destfile = paste0(normalBam, ".bai"))
}

## We can bin and count the reads
reads_gr <- getReadCountsFromBAM(BAMFiles = c(tumorBam, normalBam),
    sampleNames = c("tumor", "normal"),
    refSeqName = "chr4", WL = 10000, mode = "unpaired")

## We need a special normalization because the tumor has made large CNVs
X <- normalizeGenome(reads_gr, normType="poisson")

## detect cnv's
ref_analysis <- referencecn.mops(X[,1], X[,2],
     norm=0, 
     I = c(0.025, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 8,16,32,64), 
     classes = c("CN0", "CN1", "CN2", "CN3", "CN4", "CN5",
            "CN6", "CN7","CN8","CN16","CN32","CN64","CN128"),
     segAlgorithm="DNAcopy")
resCNMOPS <- calcIntegerCopyNumbers(ref_analysis)

## visualize the cnv's
segplot(resCNMOPS)
```

Here the x-axis represents the genomic position and the y-axis represents the 
log ratio of read counts and copy number call of each segment(red)

```{r}
human_cn <- cnvr(resCNMOPS) #look at CNV regions
human_cn
```

To find the genes that lie in these copy no regions, we will use the 
TranscriptDb  object for hg19 build 

```{r message=FALSE}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene 
txdb <- keepSeqlevels(txdb,"chr4")  #subset to work with only chr4
txdb_genes <- genes(txdb)  # get the genes from chr4
txdb_genes
```

Next we will use find overlaps to compare the gene ranges and cnv regions.
```{r}
overlaps2 = findOverlaps(txdb_genes, human_cn, type="within")
cnv <- human_cn[subjectHits(overlaps2)]
ans <- split(cnv, factor(queryHits(overlaps2)))
hitgenes <- txdb_genes$gene_id[queryHits(overlaps2)]
ans2 <- unlist(ans)
ans2$entrez_gene_id <- hitgenes

ans2
```

```{r}
sessionInfo()
```
## Epigenomics

(Martin)

Work flow

R / Bioconductor resources
